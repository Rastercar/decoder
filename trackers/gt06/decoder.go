package gt06

import (
	"errors"
	"fmt"
)

/*
 | Manual reference: http://iconcox.in/images/gt-ognProtocol.pdf
 |
 | Data Packet Format (10+N bytes)
 |
 | Format                    | Length (bytes)
 | -------------------------------------------
 | Start Bit                 | 2
 | Packet Lenght             | 1
 | Protocol Number           | 1
 | Information Content       | N
 | Information Serial Number | 2
 | Error Check               | 2
 | Stop Bit                  | 2
 | -------------------------------------------
 |
 | Packet Length:
 | Protocol Number + Information Content + Information Serial Number + Error Check
 | totally (5+N) Bytes, because the Information Content is a variable length field
 |
 | Information Content:
 | The specific contents are determined by the protocol numbers corresponding to different applications.
 |
 | Information Serial Number:
 | The serial number of the first GPRS data (including status packet and data packet such as GPS, LBS)
 | sent after booting is 1, and the serial number of data sent later at each time will be automatically
 | added 1
 |
 | Error Check:
 | A check code may be used by the terminal or the server to distinguish whether the received
 | information is error or not. To prevent errors occur during data transmission, error check is added to
 | against data misoperation, so as to increase the security and efficiency of the system. The check code
 | is generated by the CRC-ITU checking method.
 | The check codes of data in the structure of the protocol, from the Packet Length to the Information
 | Serial Number (including “Packet Length” and “Information Serial Number”) , are values of
 | CRC-ITU.
 | CRC error occur when the received information is calculated, the receiver will ignore and discard the
 | data packet.
*/

// GT06 PROTOCOL CONSTANTS

var (
	START_BIT = []byte{0x78, 0x78}
	STOP_BIT  = []byte{0x0D, 0x0A}
)

// GT06 Protocol numbers

var (
	LOGIN_MESSAGE                     = uint8(0x01)
	LOCATION_DATA                     = uint8(0x12)
	STATUS_INFORMATION                = uint8(0x13)
	STRING_INFORMATION                = uint8(0x15)
	ALARM_DATA                        = uint8(0x16)
	GPS_QUERY_ADDRESS_BY_PHONE_NUMBER = uint8(0x1A)
	CMD_INFORMATION                   = uint8(0x80)
)

type decoder struct {
	debugMode bool
}

type DecodeRes struct {
	Err     error       // the decoding error
	Res     []byte      // bytes to respond to the tracker through tcp/udp
	Msg     interface{} // nil or a serializable struct with data about the decode response
	MsgType string      // name of the struct in msg
}

func NewDecoder(debug bool) decoder {
	return decoder{debugMode: debug}
}

func (d *decoder) printfIfDebug(s string, a ...any) {
	if d.debugMode {
		fmt.Printf(s, a...)
	}
}

func (d *decoder) err(s string, a ...any) error {
	ss := fmt.Sprintf(s, a...)
	d.printfIfDebug(ss)
	return errors.New(ss)
}

func (d *decoder) Decode(msg []byte) DecodeRes {
	d.printfIfDebug("\ndecoding GT06 message")

	m, err := NewGt06Msg(msg)
	if err != nil {
		d.printfIfDebug("decoding failed: %v", err)
		return DecodeRes{Err: d.err("decoding failed: %v", err)}
	}

	var res DecodeRes

	switch m.ProtocolNumber[0] {
	case LOGIN_MESSAGE:
		res = m.DecodeLogin()
	default:
		res = DecodeRes{Err: d.err("cannot decode msg, unkown protocol %d", m.ProtocolNumber)}
	}

	if res.Err != nil {
		d.printfIfDebug("decoding failed: %v", err)
	}

	return res
}
